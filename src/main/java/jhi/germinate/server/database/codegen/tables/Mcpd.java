/*
 * This file is generated by jOOQ.
 */
package jhi.germinate.server.database.codegen.tables;


import java.math.BigDecimal;
import java.sql.Timestamp;

import jhi.germinate.server.database.codegen.GerminateDb;
import jhi.germinate.server.database.codegen.tables.records.McpdRecord;

import org.jooq.Field;
import org.jooq.Name;
import org.jooq.Schema;
import org.jooq.Table;
import org.jooq.TableField;
import org.jooq.TableOptions;
import org.jooq.UniqueKey;
import org.jooq.impl.DSL;
import org.jooq.impl.Internal;
import org.jooq.impl.SQLDataType;
import org.jooq.impl.TableImpl;


// @formatter:off
/**
 * This class is generated by jOOQ.
 */
@SuppressWarnings({ "all", "unchecked", "rawtypes" })
public class Mcpd extends TableImpl<McpdRecord> {

    private static final long serialVersionUID = 1L;

    /**
     * The reference instance of <code>germinate_db.mcpd</code>
     */
    public static final Mcpd MCPD = new Mcpd();

    /**
     * The class holding records for this type
     */
    @Override
    public Class<McpdRecord> getRecordType() {
        return McpdRecord.class;
    }

    /**
     * The column <code>germinate_db.mcpd.germinatebase_id</code>.
     */
    public final TableField<McpdRecord, Integer> GERMINATEBASE_ID = createField(DSL.name("germinatebase_id"), SQLDataType.INTEGER.nullable(false), this, "");

    /**
     * The column <code>germinate_db.mcpd.puid</code>. Any persistent, unique
     * identifier assigned to the accession so it can be unambiguously
     * referenced at the global level and the information associated with it
     * harvested through automated means. Report one PUID for each accession.
     */
    public final TableField<McpdRecord, String> PUID = createField(DSL.name("puid"), SQLDataType.CLOB, this, "Any persistent, unique identifier assigned to the accession so it can be unambiguously referenced at the global level and the information associated with it harvested through automated means. Report one PUID for each accession.");

    /**
     * The column <code>germinate_db.mcpd.instcode</code>. FAO WIEWS code of the
     * institute where the accession is maintained. The codes consist of the
     * 3-letter ISO 3166 country code of the country where the institute is
     * located plus a number (e.g. COL001). The current set of institute codes
     * is available from http://www.fao.org/wiews. For those institutes not yet
     * having an FAO Code, or for those with 'obsolete' codes, see 'Common
     * formatting rules (v)'.
     */
    public final TableField<McpdRecord, String> INSTCODE = createField(DSL.name("instcode"), SQLDataType.VARCHAR(255), this, "FAO WIEWS code of the institute where the accession is maintained. The codes consist of the 3-letter ISO 3166 country code of the country where the institute is located plus a number (e.g. COL001). The current set of institute codes is available from http://www.fao.org/wiews. For those institutes not yet having an FAO Code, or for those with 'obsolete' codes, see 'Common formatting rules (v)'.");

    /**
     * The column <code>germinate_db.mcpd.accenumb</code>. This is the unique
     * identifier for accessions within a genebank, and is assigned when a
     * sample is entered into the genebank collection (e.g. 'PI 113869').
     */
    public final TableField<McpdRecord, String> ACCENUMB = createField(DSL.name("accenumb"), SQLDataType.VARCHAR(255).nullable(false), this, "This is the unique identifier for accessions within a genebank, and is assigned when a sample is entered into the genebank collection (e.g. 'PI 113869').");

    /**
     * The column <code>germinate_db.mcpd.collnumb</code>. Original identifier
     * assigned by the collector(s) of the sample, normally composed of the name
     * or initials of the collector(s) followed by a number (e.g. 'FM9909').
     * This identifier is essential for identifying duplicates held in different
     * collections.
     */
    public final TableField<McpdRecord, String> COLLNUMB = createField(DSL.name("collnumb"), SQLDataType.VARCHAR(255), this, "Original identifier assigned by the collector(s) of the sample, normally composed of the name or initials of the collector(s) followed by a number (e.g. 'FM9909'). This identifier is essential for identifying duplicates held in different collections.");

    /**
     * The column <code>germinate_db.mcpd.collcode</code>. FAO WIEWS code of the
     * institute collecting the sample. If the holding institute has collected
     * the material, the collecting institute code (COLLCODE) should be the same
     * as the holding institute code (INSTCODE). Follows INSTCODE standard.
     * Multiple values are separated by a semicolon without space.
     */
    public final TableField<McpdRecord, String> COLLCODE = createField(DSL.name("collcode"), SQLDataType.VARCHAR(255), this, "FAO WIEWS code of the institute collecting the sample. If the holding institute has collected the material, the collecting institute code (COLLCODE) should be the same as the holding institute code (INSTCODE). Follows INSTCODE standard. Multiple values are separated by a semicolon without space.");

    /**
     * The column <code>germinate_db.mcpd.collname</code>. Name of the institute
     * collecting the sample. This descriptor should be used only if COLLCODE
     * cannot be filled because the FAO WIEWS code for this institute is not
     * available. Multiple values are separated by a semicolon without space.
     */
    public final TableField<McpdRecord, String> COLLNAME = createField(DSL.name("collname"), SQLDataType.VARCHAR(255), this, "Name of the institute collecting the sample. This descriptor should be used only if COLLCODE cannot be filled because the FAO WIEWS code for this institute is not available. Multiple values are separated by a semicolon without space.");

    /**
     * The column <code>germinate_db.mcpd.collinstaddress</code>. Address of the
     * institute collecting the sample. This descriptor should be used only if
     * COLLCODE cannot be filled since the FAO WIEWS code for this institute is
     * not available. Multiple values are separated by a semicolon without
     * space.
     */
    public final TableField<McpdRecord, String> COLLINSTADDRESS = createField(DSL.name("collinstaddress"), SQLDataType.CLOB, this, "Address of the institute collecting the sample. This descriptor should be used only if COLLCODE cannot be filled since the FAO WIEWS code for this institute is not available. Multiple values are separated by a semicolon without space.");

    /**
     * The column <code>germinate_db.mcpd.collmissid</code>. Identifier of the
     * collecting mission used by the Collecting Institute (4 or 4.1) (e.g.
     * 'CIATFOR052', 'CN426').
     */
    public final TableField<McpdRecord, String> COLLMISSID = createField(DSL.name("collmissid"), SQLDataType.VARCHAR(255), this, "Identifier of the collecting mission used by the Collecting Institute (4 or 4.1) (e.g. 'CIATFOR052', 'CN426').");

    /**
     * The column <code>germinate_db.mcpd.genus</code>. Genus name for taxon.
     * Initial uppercase letter required.
     */
    public final TableField<McpdRecord, String> GENUS = createField(DSL.name("genus"), SQLDataType.VARCHAR(255), this, "Genus name for taxon. Initial uppercase letter required.");

    /**
     * The column <code>germinate_db.mcpd.species</code>. Specific epithet
     * portion of the scientific name in lowercase letters. Only the following
     * abbreviation is allowed: 'sp.'
     */
    public final TableField<McpdRecord, String> SPECIES = createField(DSL.name("species"), SQLDataType.VARCHAR(255), this, "Specific epithet portion of the scientific name in lowercase letters. Only the following abbreviation is allowed: 'sp.'");

    /**
     * The column <code>germinate_db.mcpd.spauthor</code>. Provide the authority
     * for the species name.
     */
    public final TableField<McpdRecord, String> SPAUTHOR = createField(DSL.name("spauthor"), SQLDataType.VARCHAR(255), this, "Provide the authority for the species name.");

    /**
     * The column <code>germinate_db.mcpd.subtaxa</code>. Subtaxon can be used
     * to store any additional taxonomic identifier. The following abbreviations
     * are allowed: 'subsp.' (for subspecies); 'convar.' (for convariety);
     * 'var.' (for variety); 'f.' (for form); 'Group' (for 'cultivar group').
     */
    public final TableField<McpdRecord, String> SUBTAXA = createField(DSL.name("subtaxa"), SQLDataType.VARCHAR(255), this, "Subtaxon can be used to store any additional taxonomic identifier. The following abbreviations are allowed: 'subsp.' (for subspecies); 'convar.' (for convariety); 'var.' (for variety); 'f.' (for form); 'Group' (for 'cultivar group').");

    /**
     * The column <code>germinate_db.mcpd.subtauthor</code>. Provide the
     * subtaxon authority at the most detailed taxonomic level.
     */
    public final TableField<McpdRecord, String> SUBTAUTHOR = createField(DSL.name("subtauthor"), SQLDataType.VARCHAR(255), this, "Provide the subtaxon authority at the most detailed taxonomic level.");

    /**
     * The column <code>germinate_db.mcpd.cropname</code>. Common name of the
     * crop. Example: 'malting barley', 'macadamia', 'maïs'.
     */
    public final TableField<McpdRecord, String> CROPNAME = createField(DSL.name("cropname"), SQLDataType.VARCHAR(255), this, "Common name of the crop. Example: 'malting barley', 'macadamia', 'maïs'.");

    /**
     * The column <code>germinate_db.mcpd.accename</code>. Either a registered
     * or other designation given to the material received, other than the
     * donor's accession number (23) or collecting number (3). First letter
     * uppercase. Multiple names are separated by a semicolon without space.
     * Example: Accession name: Bogatyr;Symphony;Emma.
     */
    public final TableField<McpdRecord, String> ACCENAME = createField(DSL.name("accename"), SQLDataType.VARCHAR(255), this, "Either a registered or other designation given to the material received, other than the donor's accession number (23) or collecting number (3). First letter uppercase. Multiple names are separated by a semicolon without space. Example: Accession name: Bogatyr;Symphony;Emma.");

    /**
     * The column <code>germinate_db.mcpd.acqdate</code>. Date on which the
     * accession entered the collection where YYYY is the year, MM is the month
     * and DD is the day. Missing data (MM or DD) should be indicated with
     * hyphens or '00' [double zero].
     */
    public final TableField<McpdRecord, String> ACQDATE = createField(DSL.name("acqdate"), SQLDataType.VARCHAR(255), this, "Date on which the accession entered the collection where YYYY is the year, MM is the month and DD is the day. Missing data (MM or DD) should be indicated with hyphens or '00' [double zero].");

    /**
     * The column <code>germinate_db.mcpd.origcty</code>. 3-letter ISO 3166-1
     * code of the country in which the sample was originally collected (e.g.
     * landrace, crop wild relative, farmers' variety), bred or selected
     * (breeding lines, GMOs, segregating populations, hybrids, modern
     * cultivars, etc.).
     */
    public final TableField<McpdRecord, String> ORIGCTY = createField(DSL.name("origcty"), SQLDataType.VARCHAR(255), this, "3-letter ISO 3166-1 code of the country in which the sample was originally collected (e.g. landrace, crop wild relative, farmers' variety), bred or selected (breeding lines, GMOs, segregating populations, hybrids, modern cultivars, etc.).");

    /**
     * The column <code>germinate_db.mcpd.collsite</code>. Location information
     * below the country level that describes where the accession was collected,
     * preferable in English. This might include the distance in kilometres and
     * direction from the nearest town, village or map grid reference point,
     * (e.g. 7 km south of Curitiba in the state of Parana).
     */
    public final TableField<McpdRecord, String> COLLSITE = createField(DSL.name("collsite"), SQLDataType.VARCHAR(255), this, "Location information below the country level that describes where the accession was collected, preferable in English. This might include the distance in kilometres and direction from the nearest town, village or map grid reference point, (e.g. 7 km south of Curitiba in the state of Parana).");

    /**
     * The column <code>germinate_db.mcpd.declatitude</code>. Latitude expressed
     * in decimal degrees. Positive values are North of the Equator; negative
     * values are South of the Equator (e.g. -44.6975).
     */
    public final TableField<McpdRecord, BigDecimal> DECLATITUDE = createField(DSL.name("declatitude"), SQLDataType.DECIMAL(64, 10), this, "Latitude expressed in decimal degrees. Positive values are North of the Equator; negative values are South of the Equator (e.g. -44.6975).");

    /**
     * The column <code>germinate_db.mcpd.latitude</code>. Degrees (2 digits)
     * minutes (2 digits), and seconds (2 digits) followed by N (North) or S
     * (South) (e.g. 103020S). Every missing digit (minutes or seconds) should
     * be indicated with a hyphen. Leading zeros are required (e.g. 10----S;
     * 011530N; 4531--S).
     */
    public final TableField<McpdRecord, String> LATITUDE = createField(DSL.name("latitude"), SQLDataType.VARCHAR(255), this, "Degrees (2 digits) minutes (2 digits), and seconds (2 digits) followed by N (North) or S (South) (e.g. 103020S). Every missing digit (minutes or seconds) should be indicated with a hyphen. Leading zeros are required (e.g. 10----S; 011530N; 4531--S).");

    /**
     * The column <code>germinate_db.mcpd.declongitude</code>. Longitude
     * expressed in decimal degrees. Positive values are East of the Greenwich
     * Meridian; negative values are West of the Greenwich Meridian (e.g.
     * +120.9123).
     */
    public final TableField<McpdRecord, BigDecimal> DECLONGITUDE = createField(DSL.name("declongitude"), SQLDataType.DECIMAL(64, 10), this, "Longitude expressed in decimal degrees. Positive values are East of the Greenwich Meridian; negative values are West of the Greenwich Meridian (e.g. +120.9123).");

    /**
     * The column <code>germinate_db.mcpd.longitude</code>. Degrees (3 digits),
     * minutes (2 digits), and seconds (2 digits) followed by E (East) or W
     * (West) (e.g. 0762510W). Every missing digit (minutes or seconds) should
     * be indicated with a hyphen. Leading zeros are required (e.g. 076----W).
     */
    public final TableField<McpdRecord, String> LONGITUDE = createField(DSL.name("longitude"), SQLDataType.VARCHAR(255), this, "Degrees (3 digits), minutes (2 digits), and seconds (2 digits) followed by E (East) or W (West) (e.g. 0762510W). Every missing digit (minutes or seconds) should be indicated with a hyphen. Leading zeros are required (e.g. 076----W).");

    /**
     * The column <code>germinate_db.mcpd.coorduncert</code>. Uncertainty
     * associated with the coordinates in metres. Leave the value empty if the
     * uncertainty is unknown.
     */
    public final TableField<McpdRecord, Integer> COORDUNCERT = createField(DSL.name("coorduncert"), SQLDataType.INTEGER, this, "Uncertainty associated with the coordinates in metres. Leave the value empty if the uncertainty is unknown.");

    /**
     * The column <code>germinate_db.mcpd.coorddatum</code>. The geodetic datum
     * or spatial reference system upon which the coordinates given in decimal
     * latitude and decimal longitude are based (e.g. WGS84, ETRS89, NAD83). The
     * GPS uses the WGS84 datum.
     */
    public final TableField<McpdRecord, String> COORDDATUM = createField(DSL.name("coorddatum"), SQLDataType.VARCHAR(255), this, "The geodetic datum or spatial reference system upon which the coordinates given in decimal latitude and decimal longitude are based (e.g. WGS84, ETRS89, NAD83). The GPS uses the WGS84 datum.");

    /**
     * The column <code>germinate_db.mcpd.georefmeth</code>. The georeferencing
     * method used (GPS, determined from map, gazetteer, or estimated using
     * software). Leave the value empty if georeferencing method is not known.
     */
    public final TableField<McpdRecord, String> GEOREFMETH = createField(DSL.name("georefmeth"), SQLDataType.VARCHAR(255), this, "The georeferencing method used (GPS, determined from map, gazetteer, or estimated using software). Leave the value empty if georeferencing method is not known.");

    /**
     * The column <code>germinate_db.mcpd.elevation</code>. Elevation of
     * collecting site expressed in metres above sea level. Negative values are
     * allowed.
     */
    public final TableField<McpdRecord, BigDecimal> ELEVATION = createField(DSL.name("elevation"), SQLDataType.DECIMAL(64, 10), this, "Elevation of collecting site expressed in metres above sea level. Negative values are allowed.");

    /**
     * The column <code>germinate_db.mcpd.colldate</code>. Collecting date of
     * the sample, where YYYY is the year, MM is the month and DD is the day.
     * Missing data (MM or DD) should be indicated with hyphens or '00' [double
     * zero].
     */
    public final TableField<McpdRecord, String> COLLDATE = createField(DSL.name("colldate"), SQLDataType.VARCHAR(255), this, "Collecting date of the sample, where YYYY is the year, MM is the month and DD is the day. Missing data (MM or DD) should be indicated with hyphens or '00' [double zero].");

    /**
     * The column <code>germinate_db.mcpd.bredcode</code>. FAO WIEWS code of the
     * institute that has bred the material. If the holding institute has bred
     * the material, the breeding institute code (BREDCODE) should be the same
     * as the holding institute code (INSTCODE). Follows INSTCODE standard.
     * Multiple values are separated by a semicolon without space.
     */
    public final TableField<McpdRecord, String> BREDCODE = createField(DSL.name("bredcode"), SQLDataType.VARCHAR(255), this, "FAO WIEWS code of the institute that has bred the material. If the holding institute has bred the material, the breeding institute code (BREDCODE) should be the same as the holding institute code (INSTCODE). Follows INSTCODE standard. Multiple values are separated by a semicolon without space.");

    /**
     * The column <code>germinate_db.mcpd.bredname</code>. Name of the institute
     * (or person) that bred the material. This descriptor should be used only
     * if BREDCODE cannot be filled because the FAO WIEWS code for this
     * institute is not available. Multiple names are separated by a semicolon
     * without space.
     */
    public final TableField<McpdRecord, String> BREDNAME = createField(DSL.name("bredname"), SQLDataType.VARCHAR(255), this, "Name of the institute (or person) that bred the material. This descriptor should be used only if BREDCODE cannot be filled because the FAO WIEWS code for this institute is not available. Multiple names are separated by a semicolon without space.");

    /**
     * The column <code>germinate_db.mcpd.sampstat</code>. The coding scheme
     * proposed can be used at 3 different levels of detail: either by using the
     * general codes (in boldface) such as 100, 200, 300, 400, or by using the
     * more specific codes such as 110, 120, etc.
     */
    public final TableField<McpdRecord, Integer> SAMPSTAT = createField(DSL.name("sampstat"), SQLDataType.INTEGER, this, "The coding scheme proposed can be used at 3 different levels of detail: either by using the general codes (in boldface) such as 100, 200, 300, 400, or by using the more specific codes such as 110, 120, etc.");

    /**
     * The column <code>germinate_db.mcpd.ancest</code>. Information about
     * either pedigree or other description of ancestral information (e.g.
     * parent variety in case of mutant or selection). For example a pedigree
     * 'Hanna/7*Atlas//Turk/8*Atlas' or a description 'mutation found in Hanna',
     * 'selection from Irene' or 'cross involving amongst others Hanna and
     * Irene'.
     */
    public final TableField<McpdRecord, String> ANCEST = createField(DSL.name("ancest"), SQLDataType.CLOB, this, "Information about either pedigree or other description of ancestral information (e.g. parent variety in case of mutant or selection). For example a pedigree 'Hanna/7*Atlas//Turk/8*Atlas' or a description 'mutation found in Hanna', 'selection from Irene' or 'cross involving amongst others Hanna and Irene'.");

    /**
     * The column <code>germinate_db.mcpd.collsrc</code>. The coding scheme
     * proposed can be used at 2 different levels of detail: either by using the
     * general codes (in boldface) such as 10, 20, 30, 40, etc., or by using the
     * more specific codes, such as 11, 12, etc.
     */
    public final TableField<McpdRecord, Integer> COLLSRC = createField(DSL.name("collsrc"), SQLDataType.INTEGER, this, "The coding scheme proposed can be used at 2 different levels of detail: either by using the general codes (in boldface) such as 10, 20, 30, 40, etc., or by using the more specific codes, such as 11, 12, etc.");

    /**
     * The column <code>germinate_db.mcpd.donorcode</code>. FAO WIEWS code of
     * the donor institute. Follows INSTCODE standard.
     */
    public final TableField<McpdRecord, String> DONORCODE = createField(DSL.name("donorcode"), SQLDataType.VARCHAR(255), this, "FAO WIEWS code of the donor institute. Follows INSTCODE standard.");

    /**
     * The column <code>germinate_db.mcpd.donorname</code>. Name of the donor
     * institute (or person). This descriptor should be used only if DONORCODE
     * cannot be filled because the FAO WIEWS code for this institute is not
     * available.
     */
    public final TableField<McpdRecord, String> DONORNAME = createField(DSL.name("donorname"), SQLDataType.VARCHAR(255), this, "Name of the donor institute (or person). This descriptor should be used only if DONORCODE cannot be filled because the FAO WIEWS code for this institute is not available.");

    /**
     * The column <code>germinate_db.mcpd.donornumb</code>. Identifier assigned
     * to an accession by the donor. Follows ACCENUMB standard.
     */
    public final TableField<McpdRecord, String> DONORNUMB = createField(DSL.name("donornumb"), SQLDataType.VARCHAR(255), this, "Identifier assigned to an accession by the donor. Follows ACCENUMB standard.");

    /**
     * The column <code>germinate_db.mcpd.othernumb</code>. Any other
     * identifiers known to exist in other collections for this accession. Use
     * the following format: INSTCODE:ACCENUMB;INSTCODE:identifier;… INSTCODE
     * and identifier are separated by a colon without space. Pairs of INSTCODE
     * and identifier are separated by a semicolon without space. When the
     * institute is not known, the identifier should be preceded by a colon.
     */
    public final TableField<McpdRecord, String> OTHERNUMB = createField(DSL.name("othernumb"), SQLDataType.CLOB, this, "Any other identifiers known to exist in other collections for this accession. Use the following format: INSTCODE:ACCENUMB;INSTCODE:identifier;… INSTCODE and identifier are separated by a colon without space. Pairs of INSTCODE and identifier are separated by a semicolon without space. When the institute is not known, the identifier should be preceded by a colon.");

    /**
     * The column <code>germinate_db.mcpd.duplsite</code>. FAO WIEWS code of the
     * institute(s) where a safety duplicate of the accession is maintained.
     * Multiple values are separated by a semicolon without space. Follows
     * INSTCODE standard.
     */
    public final TableField<McpdRecord, String> DUPLSITE = createField(DSL.name("duplsite"), SQLDataType.VARCHAR(255), this, "FAO WIEWS code of the institute(s) where a safety duplicate of the accession is maintained. Multiple values are separated by a semicolon without space. Follows INSTCODE standard.");

    /**
     * The column <code>germinate_db.mcpd.duplinstname</code>. Name of the
     * institute where a safety duplicate of the accession is maintained.
     * Multiple values are separated by a semicolon without space.
     */
    public final TableField<McpdRecord, String> DUPLINSTNAME = createField(DSL.name("duplinstname"), SQLDataType.VARCHAR(255), this, "Name of the institute where a safety duplicate of the accession is maintained. Multiple values are separated by a semicolon without space.");

    /**
     * The column <code>germinate_db.mcpd.storage</code>. If germplasm is
     * maintained under different types of storage, multiple choices are
     * allowed, separated by a semicolon (e.g. 20;30). (Refer to FAO/IPGRI
     * Genebank Standards 1994 for details on storage type.)
     */
    public final TableField<McpdRecord, String> STORAGE = createField(DSL.name("storage"), SQLDataType.CLOB, this, "If germplasm is maintained under different types of storage, multiple choices are allowed, separated by a semicolon (e.g. 20;30). (Refer to FAO/IPGRI Genebank Standards 1994 for details on storage type.)");

    /**
     * The column <code>germinate_db.mcpd.mlsstat</code>. The status of an
     * accession with regards to the Multilateral System (MLS) of the
     * International Treaty on Plant Genetic Resources for Food and Agriculture.
     * Leave the value empty if the status is not known
     */
    public final TableField<McpdRecord, Integer> MLSSTAT = createField(DSL.name("mlsstat"), SQLDataType.INTEGER, this, "The status of an accession with regards to the Multilateral System (MLS) of the International Treaty on Plant Genetic Resources for Food and Agriculture. Leave the value empty if the status is not known");

    /**
     * The column <code>germinate_db.mcpd.remarks</code>. The remarks field is
     * used to add notes or to elaborate on descriptors with value 99 or 999 (=
     * Other). Prefix remarks with the field name they refer to and a colon (:)
     * without space (e.g. COLLSRC:riverside). Distinct remarks referring to
     * different fields are separated by semicolons without space.
     */
    public final TableField<McpdRecord, String> REMARKS = createField(DSL.name("remarks"), SQLDataType.CLOB, this, "The remarks field is used to add notes or to elaborate on descriptors with value 99 or 999 (= Other). Prefix remarks with the field name they refer to and a colon (:) without space (e.g. COLLSRC:riverside). Distinct remarks referring to different fields are separated by semicolons without space.");

    /**
     * The column <code>germinate_db.mcpd.created_on</code>. Date and time when
     * this record was created.
     */
    public final TableField<McpdRecord, Timestamp> CREATED_ON = createField(DSL.name("created_on"), SQLDataType.TIMESTAMP(0).defaultValue(DSL.field("CURRENT_TIMESTAMP", SQLDataType.TIMESTAMP)), this, "Date and time when this record was created.");

    /**
     * The column <code>germinate_db.mcpd.updated_on</code>. Timestamp of the
     * last update to this record.
     */
    public final TableField<McpdRecord, Timestamp> UPDATED_ON = createField(DSL.name("updated_on"), SQLDataType.TIMESTAMP(0).defaultValue(DSL.field("CURRENT_TIMESTAMP", SQLDataType.TIMESTAMP)), this, "Timestamp of the last update to this record.");

    private Mcpd(Name alias, Table<McpdRecord> aliased) {
        this(alias, aliased, null);
    }

    private Mcpd(Name alias, Table<McpdRecord> aliased, Field<?>[] parameters) {
        super(alias, null, aliased, parameters, DSL.comment(""), TableOptions.table());
    }

    /**
     * Create an aliased <code>germinate_db.mcpd</code> table reference
     */
    public Mcpd(String alias) {
        this(DSL.name(alias), MCPD);
    }

    /**
     * Create an aliased <code>germinate_db.mcpd</code> table reference
     */
    public Mcpd(Name alias) {
        this(alias, MCPD);
    }

    /**
     * Create a <code>germinate_db.mcpd</code> table reference
     */
    public Mcpd() {
        this(DSL.name("mcpd"), null);
    }

    @Override
    public Schema getSchema() {
        return aliased() ? null : GerminateDb.GERMINATE_DB;
    }

    @Override
    public UniqueKey<McpdRecord> getPrimaryKey() {
        return Internal.createUniqueKey(Mcpd.MCPD, DSL.name("KEY_mcpd_PRIMARY"), new TableField[] { Mcpd.MCPD.GERMINATEBASE_ID }, true);
    }

    @Override
    public Mcpd as(String alias) {
        return new Mcpd(DSL.name(alias), this);
    }

    @Override
    public Mcpd as(Name alias) {
        return new Mcpd(alias, this);
    }

    /**
     * Rename this table
     */
    @Override
    public Mcpd rename(String name) {
        return new Mcpd(DSL.name(name), null);
    }

    /**
     * Rename this table
     */
    @Override
    public Mcpd rename(Name name) {
        return new Mcpd(name, null);
    }
    // @formatter:on
}
